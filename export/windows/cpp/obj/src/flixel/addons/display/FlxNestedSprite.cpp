// Generated by Haxe 3.4.4
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_addons_display_FlxNestedSprite
#include <flixel/addons/display/FlxNestedSprite.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxAnimationController
#include <flixel/animation/FlxAnimationController.h>
#endif
#ifndef INCLUDED_flixel_math_FlxPoint
#include <flixel/math/FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_math_FlxVelocity
#include <flixel/math/FlxVelocity.h>
#endif
#ifndef INCLUDED_flixel_util_FlxDestroyUtil
#include <flixel/util/FlxDestroyUtil.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool_flixel_math_FlxPoint
#include <flixel/util/FlxPool_flixel_math_FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPool
#include <flixel/util/IFlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_flixel_util__FlxColor_FlxColor_Impl_
#include <flixel/util/_FlxColor/FlxColor_Impl_.h>
#endif
#ifndef INCLUDED_openfl__legacy_geom_ColorTransform
#include <openfl/_legacy/geom/ColorTransform.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_a8fa2c1dc93714ae_22_new,"flixel.addons.display.FlxNestedSprite","new",0x8dc2486b,"flixel.addons.display.FlxNestedSprite.new","flixel/addons/display/FlxNestedSprite.hx",22,0x788f9bc6)
HX_LOCAL_STACK_FRAME(_hx_pos_a8fa2c1dc93714ae_85_destroy,"flixel.addons.display.FlxNestedSprite","destroy",0x6bf90685,"flixel.addons.display.FlxNestedSprite.destroy","flixel/addons/display/FlxNestedSprite.hx",85,0x788f9bc6)
HX_LOCAL_STACK_FRAME(_hx_pos_a8fa2c1dc93714ae_101_add,"flixel.addons.display.FlxNestedSprite","add",0x8db86a2c,"flixel.addons.display.FlxNestedSprite.add","flixel/addons/display/FlxNestedSprite.hx",101,0x788f9bc6)
HX_LOCAL_STACK_FRAME(_hx_pos_a8fa2c1dc93714ae_126_remove,"flixel.addons.display.FlxNestedSprite","remove",0x68ba7d19,"flixel.addons.display.FlxNestedSprite.remove","flixel/addons/display/FlxNestedSprite.hx",126,0x788f9bc6)
HX_LOCAL_STACK_FRAME(_hx_pos_a8fa2c1dc93714ae_141_removeAt,"flixel.addons.display.FlxNestedSprite","removeAt",0xea26ee6c,"flixel.addons.display.FlxNestedSprite.removeAt","flixel/addons/display/FlxNestedSprite.hx",141,0x788f9bc6)
HX_LOCAL_STACK_FRAME(_hx_pos_a8fa2c1dc93714ae_153_removeAll,"flixel.addons.display.FlxNestedSprite","removeAll",0xf7e9a988,"flixel.addons.display.FlxNestedSprite.removeAll","flixel/addons/display/FlxNestedSprite.hx",153,0x788f9bc6)
HX_LOCAL_STACK_FRAME(_hx_pos_a8fa2c1dc93714ae_158_preUpdate,"flixel.addons.display.FlxNestedSprite","preUpdate",0x12ab28d7,"flixel.addons.display.FlxNestedSprite.preUpdate","flixel/addons/display/FlxNestedSprite.hx",158,0x788f9bc6)
HX_LOCAL_STACK_FRAME(_hx_pos_a8fa2c1dc93714ae_173_update,"flixel.addons.display.FlxNestedSprite","update",0xeb3766de,"flixel.addons.display.FlxNestedSprite.update","flixel/addons/display/FlxNestedSprite.hx",173,0x788f9bc6)
HX_LOCAL_STACK_FRAME(_hx_pos_a8fa2c1dc93714ae_186_postUpdate,"flixel.addons.display.FlxNestedSprite","postUpdate",0x133975de,"flixel.addons.display.FlxNestedSprite.postUpdate","flixel/addons/display/FlxNestedSprite.hx",186,0x788f9bc6)
HX_LOCAL_STACK_FRAME(_hx_pos_a8fa2c1dc93714ae_259_draw,"flixel.addons.display.FlxNestedSprite","draw",0x75aabd99,"flixel.addons.display.FlxNestedSprite.draw","flixel/addons/display/FlxNestedSprite.hx",259,0x788f9bc6)
HX_LOCAL_STACK_FRAME(_hx_pos_a8fa2c1dc93714ae_271_drawDebug,"flixel.addons.display.FlxNestedSprite","drawDebug",0xcc2f19fa,"flixel.addons.display.FlxNestedSprite.drawDebug","flixel/addons/display/FlxNestedSprite.hx",271,0x788f9bc6)
HX_LOCAL_STACK_FRAME(_hx_pos_a8fa2c1dc93714ae_283_set_alpha,"flixel.addons.display.FlxNestedSprite","set_alpha",0x7595820c,"flixel.addons.display.FlxNestedSprite.set_alpha","flixel/addons/display/FlxNestedSprite.hx",283,0x788f9bc6)
HX_LOCAL_STACK_FRAME(_hx_pos_a8fa2c1dc93714ae_332_set_color,"flixel.addons.display.FlxNestedSprite","set_color",0x9e5b4c11,"flixel.addons.display.FlxNestedSprite.set_color","flixel/addons/display/FlxNestedSprite.hx",332,0x788f9bc6)
HX_LOCAL_STACK_FRAME(_hx_pos_a8fa2c1dc93714ae_402_set_facing,"flixel.addons.display.FlxNestedSprite","set_facing",0x0f05bcac,"flixel.addons.display.FlxNestedSprite.set_facing","flixel/addons/display/FlxNestedSprite.hx",402,0x788f9bc6)
HX_LOCAL_STACK_FRAME(_hx_pos_a8fa2c1dc93714ae_418_get_count,"flixel.addons.display.FlxNestedSprite","get_count",0xbb113371,"flixel.addons.display.FlxNestedSprite.get_count","flixel/addons/display/FlxNestedSprite.hx",418,0x788f9bc6)
namespace flixel{
namespace addons{
namespace display{

void FlxNestedSprite_obj::__construct( ::Dynamic X, ::Dynamic Y, ::Dynamic SimpleGraphic){
            	HX_STACKFRAME(&_hx_pos_a8fa2c1dc93714ae_22_new)
HXLINE(  77)		this->_parentBlue = ((Float)1);
HXLINE(  76)		this->_parentGreen = ((Float)1);
HXLINE(  75)		this->_parentRed = ((Float)1);
HXLINE(  68)		this->children = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  63)		 ::flixel::math::FlxPoint point = ::flixel::math::FlxPoint_obj::_pool->get()->set((int)0,(int)0);
HXDLIN(  63)		point->_inPool = false;
HXDLIN(  63)		this->relativeAcceleration = point;
HXLINE(  58)		 ::flixel::math::FlxPoint point1 = ::flixel::math::FlxPoint_obj::_pool->get()->set((int)0,(int)0);
HXDLIN(  58)		point1->_inPool = false;
HXDLIN(  58)		this->relativeVelocity = point1;
HXLINE(  53)		 ::flixel::math::FlxPoint point2 = ::flixel::math::FlxPoint_obj::_pool->get()->set((int)1,(int)1);
HXDLIN(  53)		point2->_inPool = false;
HXDLIN(  53)		this->relativeScale = point2;
HXLINE(  48)		this->relativeAlpha = ((Float)1);
HXLINE(  46)		this->relativeAngularAcceleration = ((Float)0);
HXLINE(  41)		this->relativeAngularVelocity = ((Float)0);
HXLINE(  36)		this->relativeAngle = ((Float)0);
HXLINE(  31)		this->relativeY = ((Float)0);
HXLINE(  27)		this->relativeX = ((Float)0);
HXLINE(  22)		super::__construct(X,Y,SimpleGraphic);
            	}

Dynamic FlxNestedSprite_obj::__CreateEmpty() { return new FlxNestedSprite_obj; }

void *FlxNestedSprite_obj::_hx_vtable = 0;

Dynamic FlxNestedSprite_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< FlxNestedSprite_obj > _hx_result = new FlxNestedSprite_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2]);
	return _hx_result;
}

bool FlxNestedSprite_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x25a685e0) {
		if (inClassId<=(int)0x0b6ffd77) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x0b6ffd77;
		} else {
			return inClassId==(int)0x25a685e0;
		}
	} else {
		return inClassId==(int)0x2e105115 || inClassId==(int)0x6706dc1b;
	}
}

void FlxNestedSprite_obj::destroy(){
            	HX_STACKFRAME(&_hx_pos_a8fa2c1dc93714ae_85_destroy)
HXLINE(  86)		this->super::destroy();
HXLINE(  88)		this->relativeScale = ( ( ::flixel::math::FlxPoint)(::flixel::util::FlxDestroyUtil_obj::put(this->relativeScale)) );
HXLINE(  89)		this->relativeVelocity = ( ( ::flixel::math::FlxPoint)(::flixel::util::FlxDestroyUtil_obj::put(this->relativeVelocity)) );
HXLINE(  90)		this->relativeAcceleration = ( ( ::flixel::math::FlxPoint)(::flixel::util::FlxDestroyUtil_obj::put(this->relativeAcceleration)) );
HXLINE(  91)		this->children = ::flixel::util::FlxDestroyUtil_obj::destroyArray(this->children);
            	}


 ::flixel::addons::display::FlxNestedSprite FlxNestedSprite_obj::add( ::flixel::addons::display::FlxNestedSprite Child){
            	HX_STACKFRAME(&_hx_pos_a8fa2c1dc93714ae_101_add)
HXLINE( 102)		if ((this->children->indexOf(Child,null()) != (int)-1)) {
HXLINE( 103)			return Child;
            		}
HXLINE( 105)		this->children->push(Child);
HXLINE( 106)		Child->velocity->set((int)0,(int)0);
HXLINE( 107)		Child->acceleration->set((int)0,(int)0);
HXLINE( 108)		{
HXLINE( 108)			 ::flixel::math::FlxPoint _this = Child->scrollFactor;
HXDLIN( 108)			 ::flixel::math::FlxPoint point = this->scrollFactor;
HXDLIN( 108)			_this->set_x(point->x);
HXDLIN( 108)			_this->set_y(point->y);
HXDLIN( 108)			if (point->_weak) {
HXLINE( 108)				point->put();
            			}
            		}
HXLINE( 110)		Child->set_alpha((Child->relativeAlpha * this->alpha));
HXLINE( 111)		Child->_parentRed = ((Float)((int)((int)this->color >> (int)(int)16) & (int)(int)255) / (Float)(int)255);
HXLINE( 112)		Child->_parentGreen = ((Float)((int)((int)this->color >> (int)(int)8) & (int)(int)255) / (Float)(int)255);
HXLINE( 113)		Child->_parentBlue = ((Float)((int)this->color & (int)(int)255) / (Float)(int)255);
HXLINE( 114)		Child->set_color(Child->color);
HXLINE( 116)		return Child;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxNestedSprite_obj,add,return )

 ::flixel::addons::display::FlxNestedSprite FlxNestedSprite_obj::remove( ::flixel::addons::display::FlxNestedSprite Child){
            	HX_STACKFRAME(&_hx_pos_a8fa2c1dc93714ae_126_remove)
HXLINE( 127)		int index = this->children->indexOf(Child,null());
HXLINE( 129)		if ((index >= (int)0)) {
HXLINE( 130)			this->children->removeRange(index,(int)1);
            		}
HXLINE( 132)		return Child;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxNestedSprite_obj,remove,return )

 ::flixel::addons::display::FlxNestedSprite FlxNestedSprite_obj::removeAt(hx::Null< int >  __o_Index){
int Index = __o_Index.Default(0);
            	HX_STACKFRAME(&_hx_pos_a8fa2c1dc93714ae_141_removeAt)
HXLINE( 142)		bool _hx_tmp;
HXDLIN( 142)		if ((this->children->length >= Index)) {
HXLINE( 142)			_hx_tmp = (Index < (int)0);
            		}
            		else {
HXLINE( 142)			_hx_tmp = true;
            		}
HXDLIN( 142)		if (_hx_tmp) {
HXLINE( 143)			return null();
            		}
HXLINE( 145)		return this->remove(this->children->__get(Index).StaticCast<  ::flixel::addons::display::FlxNestedSprite >());
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxNestedSprite_obj,removeAt,return )

void FlxNestedSprite_obj::removeAll(){
            	HX_STACKFRAME(&_hx_pos_a8fa2c1dc93714ae_153_removeAll)
HXDLIN( 153)		int _g = (int)0;
HXDLIN( 153)		::Array< ::Dynamic> _g1 = this->children;
HXDLIN( 153)		while((_g < _g1->length)){
HXDLIN( 153)			 ::flixel::addons::display::FlxNestedSprite child = _g1->__get(_g).StaticCast<  ::flixel::addons::display::FlxNestedSprite >();
HXDLIN( 153)			_g = (_g + (int)1);
HXLINE( 154)			this->remove(child);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxNestedSprite_obj,removeAll,(void))

void FlxNestedSprite_obj::preUpdate(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_a8fa2c1dc93714ae_158_preUpdate)
HXLINE( 160)		::flixel::FlxBasic_obj::activeCount++;
HXLINE( 163)		this->last->set(this->x,this->y);
HXLINE( 165)		{
HXLINE( 165)			int _g = (int)0;
HXDLIN( 165)			::Array< ::Dynamic> _g1 = this->children;
HXDLIN( 165)			while((_g < _g1->length)){
HXLINE( 165)				 ::flixel::addons::display::FlxNestedSprite child = _g1->__get(_g).StaticCast<  ::flixel::addons::display::FlxNestedSprite >();
HXDLIN( 165)				_g = (_g + (int)1);
HXLINE( 167)				bool _hx_tmp;
HXDLIN( 167)				if (child->active) {
HXLINE( 167)					_hx_tmp = child->exists;
            				}
            				else {
HXLINE( 167)					_hx_tmp = false;
            				}
HXDLIN( 167)				if (_hx_tmp) {
HXLINE( 168)					child->preUpdate(elapsed);
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxNestedSprite_obj,preUpdate,(void))

void FlxNestedSprite_obj::update(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_a8fa2c1dc93714ae_173_update)
HXLINE( 174)		this->preUpdate(elapsed);
HXLINE( 176)		{
HXLINE( 176)			int _g = (int)0;
HXDLIN( 176)			::Array< ::Dynamic> _g1 = this->children;
HXDLIN( 176)			while((_g < _g1->length)){
HXLINE( 176)				 ::flixel::addons::display::FlxNestedSprite child = _g1->__get(_g).StaticCast<  ::flixel::addons::display::FlxNestedSprite >();
HXDLIN( 176)				_g = (_g + (int)1);
HXLINE( 178)				bool _hx_tmp;
HXDLIN( 178)				if (child->active) {
HXLINE( 178)					_hx_tmp = child->exists;
            				}
            				else {
HXLINE( 178)					_hx_tmp = false;
            				}
HXDLIN( 178)				if (_hx_tmp) {
HXLINE( 179)					child->update(elapsed);
            				}
            			}
            		}
HXLINE( 182)		this->postUpdate(elapsed);
            	}


void FlxNestedSprite_obj::postUpdate(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_a8fa2c1dc93714ae_186_postUpdate)
HXLINE( 187)		if (this->moves) {
HXLINE( 188)			this->updateMotion(elapsed);
            		}
HXLINE( 190)		this->wasTouching = this->touching;
HXLINE( 191)		this->touching = (int)0;
HXLINE( 192)		this->animation->update(elapsed);
HXLINE( 194)		Float delta;
HXLINE( 195)		Float velocityDelta;
HXLINE( 197)		Float velocityDelta1 = ::flixel::math::FlxVelocity_obj::computeVelocity(this->relativeAngularVelocity,this->relativeAngularAcceleration,this->angularDrag,this->maxAngular,elapsed);
HXDLIN( 197)		velocityDelta = (((Float)0.5) * (velocityDelta1 - this->relativeAngularVelocity));
HXLINE( 198)		 ::flixel::addons::display::FlxNestedSprite _hx_tmp = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 198)		_hx_tmp->relativeAngularVelocity = (_hx_tmp->relativeAngularVelocity + velocityDelta);
HXLINE( 199)		 ::flixel::addons::display::FlxNestedSprite _hx_tmp1 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 199)		_hx_tmp1->relativeAngle = (_hx_tmp1->relativeAngle + (this->relativeAngularVelocity * elapsed));
HXLINE( 200)		 ::flixel::addons::display::FlxNestedSprite _hx_tmp2 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 200)		_hx_tmp2->relativeAngularVelocity = (_hx_tmp2->relativeAngularVelocity + velocityDelta);
HXLINE( 202)		Float velocityDelta2 = ::flixel::math::FlxVelocity_obj::computeVelocity(this->relativeVelocity->x,this->relativeAcceleration->x,this->drag->x,this->maxVelocity->x,elapsed);
HXDLIN( 202)		velocityDelta = (((Float)0.5) * (velocityDelta2 - this->relativeVelocity->x));
HXLINE( 203)		{
HXLINE( 203)			 ::flixel::math::FlxPoint _g = this->relativeVelocity;
HXDLIN( 203)			_g->set_x((_g->x + velocityDelta));
            		}
HXLINE( 204)		delta = (this->relativeVelocity->x * elapsed);
HXLINE( 205)		{
HXLINE( 205)			 ::flixel::math::FlxPoint _g1 = this->relativeVelocity;
HXDLIN( 205)			_g1->set_x((_g1->x + velocityDelta));
            		}
HXLINE( 206)		 ::flixel::addons::display::FlxNestedSprite _hx_tmp3 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 206)		_hx_tmp3->relativeX = (_hx_tmp3->relativeX + delta);
HXLINE( 208)		Float velocityDelta3 = ::flixel::math::FlxVelocity_obj::computeVelocity(this->relativeVelocity->y,this->relativeAcceleration->y,this->drag->y,this->maxVelocity->y,elapsed);
HXDLIN( 208)		velocityDelta = (((Float)0.5) * (velocityDelta3 - this->relativeVelocity->y));
HXLINE( 209)		{
HXLINE( 209)			 ::flixel::math::FlxPoint _g2 = this->relativeVelocity;
HXDLIN( 209)			_g2->set_y((_g2->y + velocityDelta));
            		}
HXLINE( 210)		delta = (this->relativeVelocity->y * elapsed);
HXLINE( 211)		{
HXLINE( 211)			 ::flixel::math::FlxPoint _g3 = this->relativeVelocity;
HXDLIN( 211)			_g3->set_y((_g3->y + velocityDelta));
            		}
HXLINE( 212)		 ::flixel::addons::display::FlxNestedSprite _hx_tmp4 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 212)		_hx_tmp4->relativeY = (_hx_tmp4->relativeY + delta);
HXLINE( 214)		{
HXLINE( 214)			int _g4 = (int)0;
HXDLIN( 214)			::Array< ::Dynamic> _g11 = this->children;
HXDLIN( 214)			while((_g4 < _g11->length)){
HXLINE( 214)				 ::flixel::addons::display::FlxNestedSprite child = _g11->__get(_g4).StaticCast<  ::flixel::addons::display::FlxNestedSprite >();
HXDLIN( 214)				_g4 = (_g4 + (int)1);
HXLINE( 216)				bool _hx_tmp5;
HXDLIN( 216)				if (child->active) {
HXLINE( 216)					_hx_tmp5 = child->exists;
            				}
            				else {
HXLINE( 216)					_hx_tmp5 = false;
            				}
HXDLIN( 216)				if (_hx_tmp5) {
HXLINE( 218)					 ::flixel::math::FlxPoint child1 = child->velocity;
HXDLIN( 218)					child1->set_x(child->velocity->set_y((int)0));
HXLINE( 219)					 ::flixel::math::FlxPoint child2 = child->acceleration;
HXDLIN( 219)					child2->set_x(child->acceleration->set_y((int)0));
HXLINE( 220)					child->angularVelocity = (child->angularAcceleration = (int)0);
HXLINE( 221)					child->postUpdate(elapsed);
HXLINE( 223)					if (this->isSimpleRender(this->get_camera())) {
HXLINE( 225)						child->set_x(((this->x + child->relativeX) - this->offset->x));
HXLINE( 226)						child->set_y(((this->y + child->relativeY) - this->offset->y));
            					}
            					else {
HXLINE( 230)						Float radians = this->angle;
HXDLIN( 230)						Float radians1 = (radians * ((Float)::Math_obj::PI / (Float)(int)180));
HXLINE( 231)						Float cos = ::Math_obj::cos(radians1);
HXLINE( 232)						Float sin = ::Math_obj::sin(radians1);
HXLINE( 234)						Float dx = ((Float)this->get_width() / (Float)(int)2);
HXDLIN( 234)						Float dx1 = (dx - ((Float)child->get_width() / (Float)(int)2));
HXDLIN( 234)						Float dx2 = (dx1 - this->offset->x);
HXLINE( 235)						Float dx3 = (this->scale->x * cos);
HXDLIN( 235)						Float child3 = child->relativeX;
HXDLIN( 235)						Float dx4 = (child3 - ((Float)this->get_width() / (Float)(int)2));
HXDLIN( 235)						dx2 = (dx2 + (dx3 * (dx4 + ((Float)child->get_width() / (Float)(int)2))));
HXLINE( 236)						Float dx5 = (this->scale->y * sin);
HXDLIN( 236)						Float child4 = child->relativeY;
HXDLIN( 236)						Float dx6 = (child4 - ((Float)this->get_height() / (Float)(int)2));
HXDLIN( 236)						dx2 = (dx2 - (dx5 * (dx6 + ((Float)child->get_height() / (Float)(int)2))));
HXLINE( 238)						Float dy = ((Float)this->get_height() / (Float)(int)2);
HXDLIN( 238)						Float dy1 = (dy - ((Float)child->get_height() / (Float)(int)2));
HXDLIN( 238)						Float dy2 = (dy1 - this->offset->y);
HXLINE( 239)						Float dy3 = (this->scale->y * cos);
HXDLIN( 239)						Float child5 = child->relativeY;
HXDLIN( 239)						Float dy4 = (child5 - ((Float)this->get_height() / (Float)(int)2));
HXDLIN( 239)						dy2 = (dy2 + (dy3 * (dy4 + ((Float)child->get_height() / (Float)(int)2))));
HXLINE( 240)						Float dy5 = (this->scale->x * sin);
HXDLIN( 240)						Float child6 = child->relativeX;
HXDLIN( 240)						Float dy6 = (child6 - ((Float)this->get_width() / (Float)(int)2));
HXDLIN( 240)						dy2 = (dy2 + (dy5 * (dy6 + ((Float)child->get_width() / (Float)(int)2))));
HXLINE( 242)						child->set_x((this->x + dx2));
HXLINE( 243)						child->set_y((this->y + dy2));
            					}
HXLINE( 246)					child->set_angle((this->angle + child->relativeAngle));
HXLINE( 247)					 ::flixel::math::FlxPoint child7 = child->scale;
HXDLIN( 247)					child7->set_x((this->scale->x * child->relativeScale->x));
HXLINE( 248)					 ::flixel::math::FlxPoint child8 = child->scale;
HXDLIN( 248)					child8->set_y((this->scale->y * child->relativeScale->y));
HXLINE( 250)					child->velocity->set_x(this->velocity->x);
HXLINE( 251)					child->velocity->set_y(this->velocity->y);
HXLINE( 252)					child->acceleration->set_x(this->acceleration->x);
HXLINE( 253)					child->acceleration->set_y(this->acceleration->y);
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxNestedSprite_obj,postUpdate,(void))

void FlxNestedSprite_obj::draw(){
            	HX_STACKFRAME(&_hx_pos_a8fa2c1dc93714ae_259_draw)
HXLINE( 260)		this->super::draw();
HXLINE( 262)		{
HXLINE( 262)			int _g = (int)0;
HXDLIN( 262)			::Array< ::Dynamic> _g1 = this->children;
HXDLIN( 262)			while((_g < _g1->length)){
HXLINE( 262)				 ::flixel::addons::display::FlxNestedSprite child = _g1->__get(_g).StaticCast<  ::flixel::addons::display::FlxNestedSprite >();
HXDLIN( 262)				_g = (_g + (int)1);
HXLINE( 264)				bool _hx_tmp;
HXDLIN( 264)				if (child->exists) {
HXLINE( 264)					_hx_tmp = child->visible;
            				}
            				else {
HXLINE( 264)					_hx_tmp = false;
            				}
HXDLIN( 264)				if (_hx_tmp) {
HXLINE( 265)					child->draw();
            				}
            			}
            		}
            	}


void FlxNestedSprite_obj::drawDebug(){
            	HX_STACKFRAME(&_hx_pos_a8fa2c1dc93714ae_271_drawDebug)
HXLINE( 272)		this->super::drawDebug();
HXLINE( 274)		{
HXLINE( 274)			int _g = (int)0;
HXDLIN( 274)			::Array< ::Dynamic> _g1 = this->children;
HXDLIN( 274)			while((_g < _g1->length)){
HXLINE( 274)				 ::flixel::addons::display::FlxNestedSprite child = _g1->__get(_g).StaticCast<  ::flixel::addons::display::FlxNestedSprite >();
HXDLIN( 274)				_g = (_g + (int)1);
HXLINE( 276)				bool _hx_tmp;
HXDLIN( 276)				if (child->exists) {
HXLINE( 276)					_hx_tmp = child->visible;
            				}
            				else {
HXLINE( 276)					_hx_tmp = false;
            				}
HXDLIN( 276)				if (_hx_tmp) {
HXLINE( 277)					child->drawDebug();
            				}
            			}
            		}
            	}


Float FlxNestedSprite_obj::set_alpha(Float Alpha){
            	HX_GC_STACKFRAME(&_hx_pos_a8fa2c1dc93714ae_283_set_alpha)
HXLINE( 284)		Float lowerBound;
HXDLIN( 284)		if ((Alpha < (int)0)) {
HXLINE( 284)			lowerBound = (int)0;
            		}
            		else {
HXLINE( 284)			lowerBound = Alpha;
            		}
HXDLIN( 284)		 ::Dynamic Alpha1;
HXDLIN( 284)		if ((lowerBound > (int)1)) {
HXLINE( 284)			Alpha1 = (int)1;
            		}
            		else {
HXLINE( 284)			Alpha1 = lowerBound;
            		}
HXDLIN( 284)		Alpha = Alpha1;
HXLINE( 285)		if ((Alpha == this->alpha)) {
HXLINE( 286)			return this->alpha;
            		}
HXLINE( 288)		this->alpha = (Alpha * this->relativeAlpha);
HXLINE( 290)		bool _hx_tmp;
HXDLIN( 290)		if ((this->alpha == (int)1)) {
HXLINE( 290)			_hx_tmp = (this->color != (int)16777215);
            		}
            		else {
HXLINE( 290)			_hx_tmp = true;
            		}
HXDLIN( 290)		if (_hx_tmp) {
HXLINE( 292)			Float red = ((Float)(((int)this->color >> (int)(int)16) * this->_parentRed) / (Float)(int)255);
HXLINE( 293)			Float green = ((Float)(((int)((int)this->color >> (int)(int)8) & (int)(int)255) * this->_parentGreen) / (Float)(int)255);
HXLINE( 294)			Float blue = ((Float)(((int)this->color & (int)(int)255) * this->_parentBlue) / (Float)(int)255);
HXLINE( 296)			if (hx::IsNull( this->colorTransform )) {
HXLINE( 298)				this->colorTransform =  ::openfl::_legacy::geom::ColorTransform_obj::__alloc( HX_CTX ,red,green,blue,this->alpha,null(),null(),null(),null());
            			}
            			else {
HXLINE( 302)				this->colorTransform->redMultiplier = red;
HXLINE( 303)				this->colorTransform->greenMultiplier = green;
HXLINE( 304)				this->colorTransform->blueMultiplier = blue;
HXLINE( 305)				this->colorTransform->alphaMultiplier = this->alpha;
            			}
HXLINE( 307)			this->useColorTransform = true;
            		}
            		else {
HXLINE( 311)			if (hx::IsNotNull( this->colorTransform )) {
HXLINE( 313)				this->colorTransform->redMultiplier = (int)1;
HXLINE( 314)				this->colorTransform->greenMultiplier = (int)1;
HXLINE( 315)				this->colorTransform->blueMultiplier = (int)1;
HXLINE( 316)				this->colorTransform->alphaMultiplier = (int)1;
            			}
HXLINE( 318)			this->useColorTransform = false;
            		}
HXLINE( 320)		this->dirty = true;
HXLINE( 322)		if (hx::IsNotNull( this->children )) {
HXLINE( 324)			int _g = (int)0;
HXDLIN( 324)			::Array< ::Dynamic> _g1 = this->children;
HXDLIN( 324)			while((_g < _g1->length)){
HXLINE( 324)				 ::flixel::addons::display::FlxNestedSprite child = _g1->__get(_g).StaticCast<  ::flixel::addons::display::FlxNestedSprite >();
HXDLIN( 324)				_g = (_g + (int)1);
HXLINE( 325)				child->set_alpha(this->alpha);
            			}
            		}
HXLINE( 328)		return this->alpha;
            	}


int FlxNestedSprite_obj::set_color(int Color){
            	HX_GC_STACKFRAME(&_hx_pos_a8fa2c1dc93714ae_332_set_color)
HXLINE( 333)		Color = ((int)Color & (int)(int)16777215);
HXLINE( 335)		Float combinedRed = ((Float)(((int)Color >> (int)(int)16) * this->_parentRed) / (Float)(int)255);
HXLINE( 336)		Float combinedGreen = ((Float)(((int)((int)Color >> (int)(int)8) & (int)(int)255) * this->_parentGreen) / (Float)(int)255);
HXLINE( 337)		Float combinedBlue = ((Float)(((int)Color & (int)(int)255) * this->_parentBlue) / (Float)(int)255);
HXLINE( 339)		int color = ::flixel::util::_FlxColor::FlxColor_Impl__obj::_new(null());
HXDLIN( 339)		{
HXLINE( 339)			int Value = ::Math_obj::round((combinedRed * (int)255));
HXDLIN( 339)			color = ((int)color & (int)(int)-16711681);
HXDLIN( 339)			int color1;
HXDLIN( 339)			if ((Value > (int)255)) {
HXLINE( 339)				color1 = (int)255;
            			}
            			else {
HXLINE( 339)				if ((Value < (int)0)) {
HXLINE( 339)					color1 = (int)0;
            				}
            				else {
HXLINE( 339)					color1 = Value;
            				}
            			}
HXDLIN( 339)			color = ((int)color | (int)((int)color1 << (int)(int)16));
            		}
HXDLIN( 339)		{
HXLINE( 339)			int Value1 = ::Math_obj::round((combinedGreen * (int)255));
HXDLIN( 339)			color = ((int)color & (int)(int)-65281);
HXDLIN( 339)			int color2;
HXDLIN( 339)			if ((Value1 > (int)255)) {
HXLINE( 339)				color2 = (int)255;
            			}
            			else {
HXLINE( 339)				if ((Value1 < (int)0)) {
HXLINE( 339)					color2 = (int)0;
            				}
            				else {
HXLINE( 339)					color2 = Value1;
            				}
            			}
HXDLIN( 339)			color = ((int)color | (int)((int)color2 << (int)(int)8));
            		}
HXDLIN( 339)		{
HXLINE( 339)			int Value2 = ::Math_obj::round((combinedBlue * (int)255));
HXDLIN( 339)			color = ((int)color & (int)(int)-256);
HXDLIN( 339)			int color3;
HXDLIN( 339)			if ((Value2 > (int)255)) {
HXLINE( 339)				color3 = (int)255;
            			}
            			else {
HXLINE( 339)				if ((Value2 < (int)0)) {
HXLINE( 339)					color3 = (int)0;
            				}
            				else {
HXLINE( 339)					color3 = Value2;
            				}
            			}
HXDLIN( 339)			color = ((int)color | (int)color3);
            		}
HXDLIN( 339)		{
HXLINE( 339)			int Value3 = ::Math_obj::round((int)0);
HXDLIN( 339)			color = ((int)color & (int)(int)16777215);
HXDLIN( 339)			int color4;
HXDLIN( 339)			if ((Value3 > (int)255)) {
HXLINE( 339)				color4 = (int)255;
            			}
            			else {
HXLINE( 339)				if ((Value3 < (int)0)) {
HXLINE( 339)					color4 = (int)0;
            				}
            				else {
HXLINE( 339)					color4 = Value3;
            				}
            			}
HXDLIN( 339)			color = ((int)color | (int)((int)color4 << (int)(int)24));
            		}
HXDLIN( 339)		int combinedColor = color;
HXLINE( 341)		if ((this->color == combinedColor)) {
HXLINE( 342)			return this->color;
            		}
HXLINE( 344)		this->color = combinedColor;
HXLINE( 345)		bool _hx_tmp;
HXDLIN( 345)		if ((this->alpha == (int)1)) {
HXLINE( 345)			_hx_tmp = (this->color != (int)16777215);
            		}
            		else {
HXLINE( 345)			_hx_tmp = true;
            		}
HXDLIN( 345)		if (_hx_tmp) {
HXLINE( 347)			if (hx::IsNull( this->colorTransform )) {
HXLINE( 349)				this->colorTransform =  ::openfl::_legacy::geom::ColorTransform_obj::__alloc( HX_CTX ,combinedRed,combinedGreen,combinedBlue,this->alpha,null(),null(),null(),null());
            			}
            			else {
HXLINE( 353)				this->colorTransform->redMultiplier = combinedRed;
HXLINE( 354)				this->colorTransform->greenMultiplier = combinedGreen;
HXLINE( 355)				this->colorTransform->blueMultiplier = combinedBlue;
HXLINE( 356)				this->colorTransform->alphaMultiplier = this->alpha;
            			}
HXLINE( 358)			this->useColorTransform = true;
            		}
            		else {
HXLINE( 362)			if (hx::IsNotNull( this->colorTransform )) {
HXLINE( 364)				this->colorTransform->redMultiplier = (int)1;
HXLINE( 365)				this->colorTransform->greenMultiplier = (int)1;
HXLINE( 366)				this->colorTransform->blueMultiplier = (int)1;
HXLINE( 367)				this->colorTransform->alphaMultiplier = (int)1;
            			}
HXLINE( 369)			this->useColorTransform = false;
            		}
HXLINE( 372)		this->dirty = true;
HXLINE( 374)		if (::flixel::FlxG_obj::renderTile) {
HXLINE( 376)			{
HXLINE( 376)				int Value4 = ::Math_obj::round((combinedRed * (int)255));
HXDLIN( 376)				 ::flixel::addons::display::FlxNestedSprite _hx_tmp1 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 376)				_hx_tmp1->color = ((int)_hx_tmp1->color & (int)(int)-16711681);
HXDLIN( 376)				 ::flixel::addons::display::FlxNestedSprite _hx_tmp2 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 376)				int _hx_tmp3;
HXDLIN( 376)				if ((Value4 > (int)255)) {
HXLINE( 376)					_hx_tmp3 = (int)255;
            				}
            				else {
HXLINE( 376)					if ((Value4 < (int)0)) {
HXLINE( 376)						_hx_tmp3 = (int)0;
            					}
            					else {
HXLINE( 376)						_hx_tmp3 = Value4;
            					}
            				}
HXDLIN( 376)				_hx_tmp2->color = ((int)_hx_tmp2->color | (int)((int)_hx_tmp3 << (int)(int)16));
            			}
HXLINE( 377)			{
HXLINE( 377)				int Value5 = ::Math_obj::round((combinedGreen * (int)255));
HXDLIN( 377)				 ::flixel::addons::display::FlxNestedSprite _hx_tmp4 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 377)				_hx_tmp4->color = ((int)_hx_tmp4->color & (int)(int)-65281);
HXDLIN( 377)				 ::flixel::addons::display::FlxNestedSprite _hx_tmp5 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 377)				int _hx_tmp6;
HXDLIN( 377)				if ((Value5 > (int)255)) {
HXLINE( 377)					_hx_tmp6 = (int)255;
            				}
            				else {
HXLINE( 377)					if ((Value5 < (int)0)) {
HXLINE( 377)						_hx_tmp6 = (int)0;
            					}
            					else {
HXLINE( 377)						_hx_tmp6 = Value5;
            					}
            				}
HXDLIN( 377)				_hx_tmp5->color = ((int)_hx_tmp5->color | (int)((int)_hx_tmp6 << (int)(int)8));
            			}
HXLINE( 378)			{
HXLINE( 378)				int Value6 = ::Math_obj::round((combinedBlue * (int)255));
HXDLIN( 378)				 ::flixel::addons::display::FlxNestedSprite _hx_tmp7 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 378)				_hx_tmp7->color = ((int)_hx_tmp7->color & (int)(int)-256);
HXDLIN( 378)				 ::flixel::addons::display::FlxNestedSprite _hx_tmp8 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 378)				int _hx_tmp9;
HXDLIN( 378)				if ((Value6 > (int)255)) {
HXLINE( 378)					_hx_tmp9 = (int)255;
            				}
            				else {
HXLINE( 378)					if ((Value6 < (int)0)) {
HXLINE( 378)						_hx_tmp9 = (int)0;
            					}
            					else {
HXLINE( 378)						_hx_tmp9 = Value6;
            					}
            				}
HXDLIN( 378)				_hx_tmp8->color = ((int)_hx_tmp8->color | (int)_hx_tmp9);
            			}
            		}
HXLINE( 381)		{
HXLINE( 381)			int _g = (int)0;
HXDLIN( 381)			::Array< ::Dynamic> _g1 = this->children;
HXDLIN( 381)			while((_g < _g1->length)){
HXLINE( 381)				 ::flixel::addons::display::FlxNestedSprite child = _g1->__get(_g).StaticCast<  ::flixel::addons::display::FlxNestedSprite >();
HXDLIN( 381)				_g = (_g + (int)1);
HXLINE( 383)				int childColor = child->color;
HXLINE( 385)				Float childRed = ((Float)((int)childColor >> (int)(int)16) / (Float)((int)255 * child->_parentRed));
HXLINE( 386)				Float childGreen = ((Float)((int)((int)childColor >> (int)(int)8) & (int)(int)255) / (Float)((int)255 * child->_parentGreen));
HXLINE( 387)				Float childBlue = ((Float)((int)childColor & (int)(int)255) / (Float)((int)255 * child->_parentBlue));
HXLINE( 389)				int color5 = ::flixel::util::_FlxColor::FlxColor_Impl__obj::_new(null());
HXDLIN( 389)				{
HXLINE( 389)					int Value7 = ::Math_obj::round((childRed * (int)255));
HXDLIN( 389)					color5 = ((int)color5 & (int)(int)-16711681);
HXDLIN( 389)					int color6;
HXDLIN( 389)					if ((Value7 > (int)255)) {
HXLINE( 389)						color6 = (int)255;
            					}
            					else {
HXLINE( 389)						if ((Value7 < (int)0)) {
HXLINE( 389)							color6 = (int)0;
            						}
            						else {
HXLINE( 389)							color6 = Value7;
            						}
            					}
HXDLIN( 389)					color5 = ((int)color5 | (int)((int)color6 << (int)(int)16));
            				}
HXDLIN( 389)				{
HXLINE( 389)					int Value8 = ::Math_obj::round((childGreen * (int)255));
HXDLIN( 389)					color5 = ((int)color5 & (int)(int)-65281);
HXDLIN( 389)					int color7;
HXDLIN( 389)					if ((Value8 > (int)255)) {
HXLINE( 389)						color7 = (int)255;
            					}
            					else {
HXLINE( 389)						if ((Value8 < (int)0)) {
HXLINE( 389)							color7 = (int)0;
            						}
            						else {
HXLINE( 389)							color7 = Value8;
            						}
            					}
HXDLIN( 389)					color5 = ((int)color5 | (int)((int)color7 << (int)(int)8));
            				}
HXDLIN( 389)				{
HXLINE( 389)					int Value9 = ::Math_obj::round((childBlue * (int)255));
HXDLIN( 389)					color5 = ((int)color5 & (int)(int)-256);
HXDLIN( 389)					int color8;
HXDLIN( 389)					if ((Value9 > (int)255)) {
HXLINE( 389)						color8 = (int)255;
            					}
            					else {
HXLINE( 389)						if ((Value9 < (int)0)) {
HXLINE( 389)							color8 = (int)0;
            						}
            						else {
HXLINE( 389)							color8 = Value9;
            						}
            					}
HXDLIN( 389)					color5 = ((int)color5 | (int)color8);
            				}
HXDLIN( 389)				{
HXLINE( 389)					int Value10 = ::Math_obj::round((int)0);
HXDLIN( 389)					color5 = ((int)color5 & (int)(int)16777215);
HXDLIN( 389)					int color9;
HXDLIN( 389)					if ((Value10 > (int)255)) {
HXLINE( 389)						color9 = (int)255;
            					}
            					else {
HXLINE( 389)						if ((Value10 < (int)0)) {
HXLINE( 389)							color9 = (int)0;
            						}
            						else {
HXLINE( 389)							color9 = Value10;
            						}
            					}
HXDLIN( 389)					color5 = ((int)color5 | (int)((int)color9 << (int)(int)24));
            				}
HXDLIN( 389)				combinedColor = color5;
HXLINE( 391)				child->set_color(combinedColor);
HXLINE( 393)				child->_parentRed = combinedRed;
HXLINE( 394)				child->_parentGreen = combinedGreen;
HXLINE( 395)				child->_parentBlue = combinedBlue;
            			}
            		}
HXLINE( 398)		return this->color;
            	}


int FlxNestedSprite_obj::set_facing(int Direction){
            	HX_STACKFRAME(&_hx_pos_a8fa2c1dc93714ae_402_set_facing)
HXLINE( 403)		this->super::set_facing(Direction);
HXLINE( 404)		if (hx::IsNotNull( this->children )) {
HXLINE( 406)			int _g = (int)0;
HXDLIN( 406)			::Array< ::Dynamic> _g1 = this->children;
HXDLIN( 406)			while((_g < _g1->length)){
HXLINE( 406)				 ::flixel::addons::display::FlxNestedSprite child = _g1->__get(_g).StaticCast<  ::flixel::addons::display::FlxNestedSprite >();
HXDLIN( 406)				_g = (_g + (int)1);
HXLINE( 408)				bool _hx_tmp;
HXDLIN( 408)				if (child->exists) {
HXLINE( 408)					_hx_tmp = child->active;
            				}
            				else {
HXLINE( 408)					_hx_tmp = false;
            				}
HXDLIN( 408)				if (_hx_tmp) {
HXLINE( 409)					child->set_facing(Direction);
            				}
            			}
            		}
HXLINE( 413)		return Direction;
            	}


int FlxNestedSprite_obj::get_count(){
            	HX_STACKFRAME(&_hx_pos_a8fa2c1dc93714ae_418_get_count)
HXDLIN( 418)		return this->children->length;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxNestedSprite_obj,get_count,return )


hx::ObjectPtr< FlxNestedSprite_obj > FlxNestedSprite_obj::__new( ::Dynamic X, ::Dynamic Y, ::Dynamic SimpleGraphic) {
	hx::ObjectPtr< FlxNestedSprite_obj > __this = new FlxNestedSprite_obj();
	__this->__construct(X,Y,SimpleGraphic);
	return __this;
}

hx::ObjectPtr< FlxNestedSprite_obj > FlxNestedSprite_obj::__alloc(hx::Ctx *_hx_ctx, ::Dynamic X, ::Dynamic Y, ::Dynamic SimpleGraphic) {
	FlxNestedSprite_obj *__this = (FlxNestedSprite_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(FlxNestedSprite_obj), true, "flixel.addons.display.FlxNestedSprite"));
	*(void **)__this = FlxNestedSprite_obj::_hx_vtable;
	__this->__construct(X,Y,SimpleGraphic);
	return __this;
}

FlxNestedSprite_obj::FlxNestedSprite_obj()
{
}

void FlxNestedSprite_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(FlxNestedSprite);
	HX_MARK_MEMBER_NAME(relativeX,"relativeX");
	HX_MARK_MEMBER_NAME(relativeY,"relativeY");
	HX_MARK_MEMBER_NAME(relativeAngle,"relativeAngle");
	HX_MARK_MEMBER_NAME(relativeAngularVelocity,"relativeAngularVelocity");
	HX_MARK_MEMBER_NAME(relativeAngularAcceleration,"relativeAngularAcceleration");
	HX_MARK_MEMBER_NAME(relativeAlpha,"relativeAlpha");
	HX_MARK_MEMBER_NAME(relativeScale,"relativeScale");
	HX_MARK_MEMBER_NAME(relativeVelocity,"relativeVelocity");
	HX_MARK_MEMBER_NAME(relativeAcceleration,"relativeAcceleration");
	HX_MARK_MEMBER_NAME(children,"children");
	HX_MARK_MEMBER_NAME(_parentRed,"_parentRed");
	HX_MARK_MEMBER_NAME(_parentGreen,"_parentGreen");
	HX_MARK_MEMBER_NAME(_parentBlue,"_parentBlue");
	 ::flixel::FlxSprite_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void FlxNestedSprite_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(relativeX,"relativeX");
	HX_VISIT_MEMBER_NAME(relativeY,"relativeY");
	HX_VISIT_MEMBER_NAME(relativeAngle,"relativeAngle");
	HX_VISIT_MEMBER_NAME(relativeAngularVelocity,"relativeAngularVelocity");
	HX_VISIT_MEMBER_NAME(relativeAngularAcceleration,"relativeAngularAcceleration");
	HX_VISIT_MEMBER_NAME(relativeAlpha,"relativeAlpha");
	HX_VISIT_MEMBER_NAME(relativeScale,"relativeScale");
	HX_VISIT_MEMBER_NAME(relativeVelocity,"relativeVelocity");
	HX_VISIT_MEMBER_NAME(relativeAcceleration,"relativeAcceleration");
	HX_VISIT_MEMBER_NAME(children,"children");
	HX_VISIT_MEMBER_NAME(_parentRed,"_parentRed");
	HX_VISIT_MEMBER_NAME(_parentGreen,"_parentGreen");
	HX_VISIT_MEMBER_NAME(_parentBlue,"_parentBlue");
	 ::flixel::FlxSprite_obj::__Visit(HX_VISIT_ARG);
}

hx::Val FlxNestedSprite_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"add") ) { return hx::Val( add_dyn() ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"draw") ) { return hx::Val( draw_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"count") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_count() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"remove") ) { return hx::Val( remove_dyn() ); }
		if (HX_FIELD_EQ(inName,"update") ) { return hx::Val( update_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"destroy") ) { return hx::Val( destroy_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"children") ) { return hx::Val( children ); }
		if (HX_FIELD_EQ(inName,"removeAt") ) { return hx::Val( removeAt_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"relativeX") ) { return hx::Val( relativeX ); }
		if (HX_FIELD_EQ(inName,"relativeY") ) { return hx::Val( relativeY ); }
		if (HX_FIELD_EQ(inName,"removeAll") ) { return hx::Val( removeAll_dyn() ); }
		if (HX_FIELD_EQ(inName,"preUpdate") ) { return hx::Val( preUpdate_dyn() ); }
		if (HX_FIELD_EQ(inName,"drawDebug") ) { return hx::Val( drawDebug_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_alpha") ) { return hx::Val( set_alpha_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_color") ) { return hx::Val( set_color_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_count") ) { return hx::Val( get_count_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"_parentRed") ) { return hx::Val( _parentRed ); }
		if (HX_FIELD_EQ(inName,"postUpdate") ) { return hx::Val( postUpdate_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_facing") ) { return hx::Val( set_facing_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"_parentBlue") ) { return hx::Val( _parentBlue ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"_parentGreen") ) { return hx::Val( _parentGreen ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"relativeAngle") ) { return hx::Val( relativeAngle ); }
		if (HX_FIELD_EQ(inName,"relativeAlpha") ) { return hx::Val( relativeAlpha ); }
		if (HX_FIELD_EQ(inName,"relativeScale") ) { return hx::Val( relativeScale ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"relativeVelocity") ) { return hx::Val( relativeVelocity ); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"relativeAcceleration") ) { return hx::Val( relativeAcceleration ); }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"relativeAngularVelocity") ) { return hx::Val( relativeAngularVelocity ); }
		break;
	case 27:
		if (HX_FIELD_EQ(inName,"relativeAngularAcceleration") ) { return hx::Val( relativeAngularAcceleration ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val FlxNestedSprite_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"children") ) { children=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"relativeX") ) { relativeX=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"relativeY") ) { relativeY=inValue.Cast< Float >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"_parentRed") ) { _parentRed=inValue.Cast< Float >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"_parentBlue") ) { _parentBlue=inValue.Cast< Float >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"_parentGreen") ) { _parentGreen=inValue.Cast< Float >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"relativeAngle") ) { relativeAngle=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"relativeAlpha") ) { relativeAlpha=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"relativeScale") ) { relativeScale=inValue.Cast<  ::flixel::math::FlxPoint >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"relativeVelocity") ) { relativeVelocity=inValue.Cast<  ::flixel::math::FlxPoint >(); return inValue; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"relativeAcceleration") ) { relativeAcceleration=inValue.Cast<  ::flixel::math::FlxPoint >(); return inValue; }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"relativeAngularVelocity") ) { relativeAngularVelocity=inValue.Cast< Float >(); return inValue; }
		break;
	case 27:
		if (HX_FIELD_EQ(inName,"relativeAngularAcceleration") ) { relativeAngularAcceleration=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void FlxNestedSprite_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("relativeX","\x0c","\x76","\x50","\xe4"));
	outFields->push(HX_HCSTRING("relativeY","\x0d","\x76","\x50","\xe4"));
	outFields->push(HX_HCSTRING("relativeAngle","\x67","\x13","\x5f","\x88"));
	outFields->push(HX_HCSTRING("relativeAngularVelocity","\xb3","\xaf","\xc9","\x4a"));
	outFields->push(HX_HCSTRING("relativeAngularAcceleration","\xd6","\x30","\x22","\xb8"));
	outFields->push(HX_HCSTRING("relativeAlpha","\xf2","\x76","\x13","\x87"));
	outFields->push(HX_HCSTRING("relativeScale","\x1e","\x9e","\x4b","\xde"));
	outFields->push(HX_HCSTRING("relativeVelocity","\x09","\x27","\x00","\x84"));
	outFields->push(HX_HCSTRING("relativeAcceleration","\x2c","\x0b","\xd6","\xf7"));
	outFields->push(HX_HCSTRING("children","\x3f","\x19","\x6a","\x70"));
	outFields->push(HX_HCSTRING("count","\xcf","\x44","\x63","\x4a"));
	outFields->push(HX_HCSTRING("_parentRed","\x08","\x1e","\xf7","\xda"));
	outFields->push(HX_HCSTRING("_parentGreen","\x3a","\x2f","\xb1","\x90"));
	outFields->push(HX_HCSTRING("_parentBlue","\x03","\x1e","\xb5","\xb2"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo FlxNestedSprite_obj_sMemberStorageInfo[] = {
	{hx::fsFloat,(int)offsetof(FlxNestedSprite_obj,relativeX),HX_HCSTRING("relativeX","\x0c","\x76","\x50","\xe4")},
	{hx::fsFloat,(int)offsetof(FlxNestedSprite_obj,relativeY),HX_HCSTRING("relativeY","\x0d","\x76","\x50","\xe4")},
	{hx::fsFloat,(int)offsetof(FlxNestedSprite_obj,relativeAngle),HX_HCSTRING("relativeAngle","\x67","\x13","\x5f","\x88")},
	{hx::fsFloat,(int)offsetof(FlxNestedSprite_obj,relativeAngularVelocity),HX_HCSTRING("relativeAngularVelocity","\xb3","\xaf","\xc9","\x4a")},
	{hx::fsFloat,(int)offsetof(FlxNestedSprite_obj,relativeAngularAcceleration),HX_HCSTRING("relativeAngularAcceleration","\xd6","\x30","\x22","\xb8")},
	{hx::fsFloat,(int)offsetof(FlxNestedSprite_obj,relativeAlpha),HX_HCSTRING("relativeAlpha","\xf2","\x76","\x13","\x87")},
	{hx::fsObject /*::flixel::math::FlxPoint*/ ,(int)offsetof(FlxNestedSprite_obj,relativeScale),HX_HCSTRING("relativeScale","\x1e","\x9e","\x4b","\xde")},
	{hx::fsObject /*::flixel::math::FlxPoint*/ ,(int)offsetof(FlxNestedSprite_obj,relativeVelocity),HX_HCSTRING("relativeVelocity","\x09","\x27","\x00","\x84")},
	{hx::fsObject /*::flixel::math::FlxPoint*/ ,(int)offsetof(FlxNestedSprite_obj,relativeAcceleration),HX_HCSTRING("relativeAcceleration","\x2c","\x0b","\xd6","\xf7")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(FlxNestedSprite_obj,children),HX_HCSTRING("children","\x3f","\x19","\x6a","\x70")},
	{hx::fsFloat,(int)offsetof(FlxNestedSprite_obj,_parentRed),HX_HCSTRING("_parentRed","\x08","\x1e","\xf7","\xda")},
	{hx::fsFloat,(int)offsetof(FlxNestedSprite_obj,_parentGreen),HX_HCSTRING("_parentGreen","\x3a","\x2f","\xb1","\x90")},
	{hx::fsFloat,(int)offsetof(FlxNestedSprite_obj,_parentBlue),HX_HCSTRING("_parentBlue","\x03","\x1e","\xb5","\xb2")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *FlxNestedSprite_obj_sStaticStorageInfo = 0;
#endif

static ::String FlxNestedSprite_obj_sMemberFields[] = {
	HX_HCSTRING("relativeX","\x0c","\x76","\x50","\xe4"),
	HX_HCSTRING("relativeY","\x0d","\x76","\x50","\xe4"),
	HX_HCSTRING("relativeAngle","\x67","\x13","\x5f","\x88"),
	HX_HCSTRING("relativeAngularVelocity","\xb3","\xaf","\xc9","\x4a"),
	HX_HCSTRING("relativeAngularAcceleration","\xd6","\x30","\x22","\xb8"),
	HX_HCSTRING("relativeAlpha","\xf2","\x76","\x13","\x87"),
	HX_HCSTRING("relativeScale","\x1e","\x9e","\x4b","\xde"),
	HX_HCSTRING("relativeVelocity","\x09","\x27","\x00","\x84"),
	HX_HCSTRING("relativeAcceleration","\x2c","\x0b","\xd6","\xf7"),
	HX_HCSTRING("children","\x3f","\x19","\x6a","\x70"),
	HX_HCSTRING("_parentRed","\x08","\x1e","\xf7","\xda"),
	HX_HCSTRING("_parentGreen","\x3a","\x2f","\xb1","\x90"),
	HX_HCSTRING("_parentBlue","\x03","\x1e","\xb5","\xb2"),
	HX_HCSTRING("destroy","\xfa","\x2c","\x86","\x24"),
	HX_HCSTRING("add","\x21","\xf2","\x49","\x00"),
	HX_HCSTRING("remove","\x44","\x9c","\x88","\x04"),
	HX_HCSTRING("removeAt","\x57","\x6e","\x1b","\xad"),
	HX_HCSTRING("removeAll","\x3d","\x17","\xe5","\xca"),
	HX_HCSTRING("preUpdate","\x8c","\x96","\xa6","\xe5"),
	HX_HCSTRING("update","\x09","\x86","\x05","\x87"),
	HX_HCSTRING("postUpdate","\x89","\x06","\x3e","\xdc"),
	HX_HCSTRING("draw","\x04","\x2c","\x70","\x42"),
	HX_HCSTRING("drawDebug","\xaf","\x87","\x2a","\x9f"),
	HX_HCSTRING("set_alpha","\xc1","\xef","\x90","\x48"),
	HX_HCSTRING("set_color","\xc6","\xb9","\x56","\x71"),
	HX_HCSTRING("set_facing","\x57","\x4d","\x0a","\xd8"),
	HX_HCSTRING("get_count","\x26","\xa1","\x0c","\x8e"),
	::String(null()) };

static void FlxNestedSprite_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(FlxNestedSprite_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void FlxNestedSprite_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(FlxNestedSprite_obj::__mClass,"__mClass");
};

#endif

hx::Class FlxNestedSprite_obj::__mClass;

void FlxNestedSprite_obj::__register()
{
	hx::Object *dummy = new FlxNestedSprite_obj;
	FlxNestedSprite_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("flixel.addons.display.FlxNestedSprite","\xf9","\x36","\x6d","\x32");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = FlxNestedSprite_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(FlxNestedSprite_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< FlxNestedSprite_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = FlxNestedSprite_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = FlxNestedSprite_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = FlxNestedSprite_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace flixel
} // end namespace addons
} // end namespace display
