// Generated by Haxe 3.4.4
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_flixel_math_FlxPoint
#include <flixel/math/FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool_flixel_math_FlxPoint
#include <flixel/util/FlxPool_flixel_math_FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPool
#include <flixel/util/IFlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_math_MoreMath
#include <math/MoreMath.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_6a0528845ba4504b_8_degToRad,"math.MoreMath","degToRad",0x745b49bf,"math.MoreMath.degToRad","math/MoreMath.hx",8,0xdf4268ba)
HX_LOCAL_STACK_FRAME(_hx_pos_6a0528845ba4504b_11_lerpAngle,"math.MoreMath","lerpAngle",0x84929931,"math.MoreMath.lerpAngle","math/MoreMath.hx",11,0xdf4268ba)
HX_LOCAL_STACK_FRAME(_hx_pos_6a0528845ba4504b_28_wrapAngle,"math.MoreMath","wrapAngle",0xb99504fe,"math.MoreMath.wrapAngle","math/MoreMath.hx",28,0xdf4268ba)
HX_LOCAL_STACK_FRAME(_hx_pos_6a0528845ba4504b_33_clampMagnitude,"math.MoreMath","clampMagnitude",0x5c7bede0,"math.MoreMath.clampMagnitude","math/MoreMath.hx",33,0xdf4268ba)
HX_LOCAL_STACK_FRAME(_hx_pos_6a0528845ba4504b_51_magnitudeSquared,"math.MoreMath","magnitudeSquared",0x349f1482,"math.MoreMath.magnitudeSquared","math/MoreMath.hx",51,0xdf4268ba)
HX_LOCAL_STACK_FRAME(_hx_pos_6a0528845ba4504b_55_magnitude,"math.MoreMath","magnitude",0xe8a07b25,"math.MoreMath.magnitude","math/MoreMath.hx",55,0xdf4268ba)
namespace math{

void MoreMath_obj::__construct() { }

Dynamic MoreMath_obj::__CreateEmpty() { return new MoreMath_obj; }

void *MoreMath_obj::_hx_vtable = 0;

Dynamic MoreMath_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< MoreMath_obj > _hx_result = new MoreMath_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool MoreMath_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x30029e09;
}

Float MoreMath_obj::degToRad(Float v){
            	HX_STACKFRAME(&_hx_pos_6a0528845ba4504b_8_degToRad)
HXDLIN(   8)		return (v * ((Float)0.017453292519943295));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(MoreMath_obj,degToRad,return )

Float MoreMath_obj::lerpAngle(Float v1,Float v2,Float r){
            	HX_STACKFRAME(&_hx_pos_6a0528845ba4504b_11_lerpAngle)
HXLINE(  13)		v1 = ::math::MoreMath_obj::wrapAngle(v1);
HXLINE(  14)		v2 = ::math::MoreMath_obj::wrapAngle(v2);
HXLINE(  15)		Float deltaAngle = (v1 - v2);
HXLINE(  17)		if ((::Math_obj::abs(deltaAngle) > (int)180)) {
HXLINE(  19)			if ((v2 < (int)180)) {
HXLINE(  19)				v2 = (v2 + (int)360);
            			}
            			else {
HXLINE(  20)				v2 = (v2 - (int)360);
            			}
            		}
HXLINE(  23)		v1 = (v1 + (r * (v2 - v1)));
HXLINE(  24)		return v1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(MoreMath_obj,lerpAngle,return )

Float MoreMath_obj::wrapAngle(Float v){
            	HX_STACKFRAME(&_hx_pos_6a0528845ba4504b_28_wrapAngle)
HXDLIN(  28)		if ((v > (int)360)) {
HXDLIN(  28)			return ::math::MoreMath_obj::wrapAngle((v - (int)360));
            		}
            		else {
HXLINE(  29)			if ((v < (int)0)) {
HXLINE(  29)				return ::math::MoreMath_obj::wrapAngle((v + (int)360));
            			}
            			else {
HXLINE(  30)				return v;
            			}
            		}
HXLINE(  28)		return ((Float)0.);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(MoreMath_obj,wrapAngle,return )

 ::flixel::math::FlxPoint MoreMath_obj::clampMagnitude( ::flixel::math::FlxPoint v,Float limit){
            	HX_STACKFRAME(&_hx_pos_6a0528845ba4504b_33_clampMagnitude)
HXLINE(  34)		Float lengthSquared = ::math::MoreMath_obj::magnitudeSquared(v);
HXLINE(  35)		 ::flixel::math::FlxPoint point = ::flixel::math::FlxPoint_obj::_pool->get()->set((int)0,(int)0);
HXDLIN(  35)		point->_inPool = false;
HXDLIN(  35)		 ::flixel::math::FlxPoint point1 = point;
HXDLIN(  35)		point1->_weak = true;
HXDLIN(  35)		 ::flixel::math::FlxPoint returnPoint = point1;
HXLINE(  36)		bool _hx_tmp;
HXDLIN(  36)		if ((lengthSquared > (limit * limit))) {
HXLINE(  36)			_hx_tmp = (lengthSquared > (int)0);
            		}
            		else {
HXLINE(  36)			_hx_tmp = false;
            		}
HXDLIN(  36)		if (_hx_tmp) {
HXLINE(  38)			Float ratio = ((Float)limit / (Float)::Math_obj::sqrt(lengthSquared));
HXLINE(  39)			returnPoint->set_x((v->x * ratio));
HXLINE(  40)			returnPoint->set_y((v->y * ratio));
            		}
            		else {
HXLINE(  44)			returnPoint->set_x(v->x);
HXLINE(  45)			returnPoint->set_y(v->y);
            		}
HXLINE(  47)		return returnPoint;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(MoreMath_obj,clampMagnitude,return )

Float MoreMath_obj::magnitudeSquared( ::flixel::math::FlxPoint v){
            	HX_STACKFRAME(&_hx_pos_6a0528845ba4504b_51_magnitudeSquared)
HXDLIN(  51)		Float _hx_tmp = (v->x * v->x);
HXDLIN(  51)		return (_hx_tmp + (v->y * v->y));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(MoreMath_obj,magnitudeSquared,return )

Float MoreMath_obj::magnitude( ::flixel::math::FlxPoint v){
            	HX_STACKFRAME(&_hx_pos_6a0528845ba4504b_55_magnitude)
HXDLIN(  55)		return ::Math_obj::sqrt(::math::MoreMath_obj::magnitudeSquared(v));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(MoreMath_obj,magnitude,return )


MoreMath_obj::MoreMath_obj()
{
}

bool MoreMath_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"degToRad") ) { outValue = degToRad_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"lerpAngle") ) { outValue = lerpAngle_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"wrapAngle") ) { outValue = wrapAngle_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"magnitude") ) { outValue = magnitude_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"clampMagnitude") ) { outValue = clampMagnitude_dyn(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"magnitudeSquared") ) { outValue = magnitudeSquared_dyn(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *MoreMath_obj_sMemberStorageInfo = 0;
static hx::StaticInfo *MoreMath_obj_sStaticStorageInfo = 0;
#endif

static void MoreMath_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(MoreMath_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void MoreMath_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(MoreMath_obj::__mClass,"__mClass");
};

#endif

hx::Class MoreMath_obj::__mClass;

static ::String MoreMath_obj_sStaticFields[] = {
	HX_HCSTRING("degToRad","\x74","\x8f","\xb4","\x95"),
	HX_HCSTRING("lerpAngle","\xdc","\x51","\x56","\x91"),
	HX_HCSTRING("wrapAngle","\xa9","\xbd","\x58","\xc6"),
	HX_HCSTRING("clampMagnitude","\x55","\xe9","\x43","\x36"),
	HX_HCSTRING("magnitudeSquared","\x37","\x97","\xf4","\x0c"),
	HX_HCSTRING("magnitude","\xd0","\x33","\x64","\xf5"),
	::String(null())
};

void MoreMath_obj::__register()
{
	hx::Object *dummy = new MoreMath_obj;
	MoreMath_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("math.MoreMath","\x83","\x1b","\x3a","\x32");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &MoreMath_obj::__GetStatic;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = MoreMath_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(MoreMath_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< MoreMath_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = MoreMath_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = MoreMath_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = MoreMath_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace math
