// Generated by Haxe 3.4.4
#include <hxcpp.h>

#ifndef INCLUDED_cdb_Lz4Reader
#include <cdb/Lz4Reader.h>
#endif
#ifndef INCLUDED_haxe_crypto_Base64
#include <haxe/crypto/Base64.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_d62c863b817f8066_16_new,"cdb.Lz4Reader","new",0x8e2d5a8e,"cdb.Lz4Reader.new","cdb/Lz4Reader.hx",16,0xdf122e23)
HX_LOCAL_STACK_FRAME(_hx_pos_d62c863b817f8066_20_b,"cdb.Lz4Reader","b",0x45910310,"cdb.Lz4Reader.b","cdb/Lz4Reader.hx",20,0xdf122e23)
HX_LOCAL_STACK_FRAME(_hx_pos_d62c863b817f8066_23_grow,"cdb.Lz4Reader","grow",0xd4eb3a25,"cdb.Lz4Reader.grow","cdb/Lz4Reader.hx",23,0xdf122e23)
HX_LOCAL_STACK_FRAME(_hx_pos_d62c863b817f8066_33_read,"cdb.Lz4Reader","read",0xdc26a968,"cdb.Lz4Reader.read","cdb/Lz4Reader.hx",33,0xdf122e23)
static const int _hx_array_data_0ff5bb9c_7[] = {
	(int)0,(int)0,(int)0,(int)0,(int)65536,(int)262144,(int)1048576,(int)4194304,
};
HX_LOCAL_STACK_FRAME(_hx_pos_d62c863b817f8066_97_uncompress,"cdb.Lz4Reader","uncompress",0x515f668d,"cdb.Lz4Reader.uncompress","cdb/Lz4Reader.hx",97,0xdf122e23)
HX_LOCAL_STACK_FRAME(_hx_pos_d62c863b817f8066_175_decodeString,"cdb.Lz4Reader","decodeString",0x8077d0b1,"cdb.Lz4Reader.decodeString","cdb/Lz4Reader.hx",175,0xdf122e23)
HX_LOCAL_STACK_FRAME(_hx_pos_d62c863b817f8066_194_encodeBytes,"cdb.Lz4Reader","encodeBytes",0x62029ea3,"cdb.Lz4Reader.encodeBytes","cdb/Lz4Reader.hx",194,0xdf122e23)
namespace cdb{

void Lz4Reader_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_d62c863b817f8066_16_new)
            	}

Dynamic Lz4Reader_obj::__CreateEmpty() { return new Lz4Reader_obj; }

void *Lz4Reader_obj::_hx_vtable = 0;

Dynamic Lz4Reader_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Lz4Reader_obj > _hx_result = new Lz4Reader_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Lz4Reader_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x2e45df4c;
}

int Lz4Reader_obj::b(){
            	HX_STACKFRAME(&_hx_pos_d62c863b817f8066_20_b)
HXDLIN(  20)		return this->bytes->b->__get(this->pos++);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Lz4Reader_obj,b,return )

 ::haxe::io::Bytes Lz4Reader_obj::grow( ::haxe::io::Bytes out,int pos,int len){
            	HX_STACKFRAME(&_hx_pos_d62c863b817f8066_23_grow)
HXLINE(  24)		int size = out->length;
HXLINE(  25)		while(true){
HXLINE(  26)			size = ((int)(size * (int)3) >> (int)(int)1);
HXLINE(  25)			if (!((size < (pos + len)))) {
HXLINE(  25)				goto _hx_goto_2;
            			}
            		}
            		_hx_goto_2:;
HXLINE(  28)		 ::haxe::io::Bytes out2 = ::haxe::io::Bytes_obj::alloc(size);
HXLINE(  29)		out2->blit((int)0,out,(int)0,pos);
HXLINE(  30)		return out2;
            	}


HX_DEFINE_DYNAMIC_FUNC3(Lz4Reader_obj,grow,return )

 ::haxe::io::Bytes Lz4Reader_obj::read( ::haxe::io::Bytes bytes){
            	HX_STACKFRAME(&_hx_pos_d62c863b817f8066_33_read)
HXLINE(  34)		this->bytes = bytes;
HXLINE(  35)		this->pos = (int)0;
HXLINE(  36)		bool _hx_tmp;
HXDLIN(  36)		bool _hx_tmp1;
HXDLIN(  36)		bool _hx_tmp2;
HXDLIN(  36)		if ((this->bytes->b->__get(this->pos++) == (int)4)) {
HXLINE(  36)			_hx_tmp2 = (this->bytes->b->__get(this->pos++) != (int)34);
            		}
            		else {
HXLINE(  36)			_hx_tmp2 = true;
            		}
HXDLIN(  36)		if (!(_hx_tmp2)) {
HXLINE(  36)			_hx_tmp1 = (this->bytes->b->__get(this->pos++) != (int)77);
            		}
            		else {
HXLINE(  36)			_hx_tmp1 = true;
            		}
HXDLIN(  36)		if (!(_hx_tmp1)) {
HXLINE(  36)			_hx_tmp = (this->bytes->b->__get(this->pos++) != (int)24);
            		}
            		else {
HXLINE(  36)			_hx_tmp = true;
            		}
HXDLIN(  36)		if (_hx_tmp) {
HXLINE(  37)			HX_STACK_DO_THROW(HX_("Invalid header",b6,f7,77,ca));
            		}
HXLINE(  38)		int flags = this->bytes->b->__get(this->pos++);
HXLINE(  40)		if ((((int)flags >> (int)(int)6) != (int)1)) {
HXLINE(  41)			HX_STACK_DO_THROW((HX_("Invalid version ",71,d8,a6,e4) + ((int)flags >> (int)(int)6)));
            		}
HXLINE(  42)		bool blockChecksum = (((int)flags & (int)(int)16) != (int)0);
HXLINE(  43)		bool streamSize = (((int)flags & (int)(int)8) != (int)0);
HXLINE(  44)		bool streamChecksum = (((int)flags & (int)(int)4) != (int)0);
HXLINE(  45)		if ((((int)flags & (int)(int)2) != (int)0)) {
HXLINE(  45)			HX_STACK_DO_THROW(HX_("assert",c6,46,03,4c));
            		}
HXLINE(  46)		bool presetDict = (((int)flags & (int)(int)1) != (int)0);
HXLINE(  48)		int bd = this->bytes->b->__get(this->pos++);
HXLINE(  49)		if ((((int)bd & (int)(int)128) != (int)0)) {
HXLINE(  49)			HX_STACK_DO_THROW(HX_("assert",c6,46,03,4c));
            		}
HXLINE(  50)		int maxBlockSize = ::Array_obj< int >::fromData( _hx_array_data_0ff5bb9c_7,8)->__get(((int)((int)bd >> (int)(int)4) & (int)(int)7));
HXLINE(  51)		if ((maxBlockSize == (int)0)) {
HXLINE(  51)			HX_STACK_DO_THROW(HX_("assert",c6,46,03,4c));
            		}
HXLINE(  52)		if ((((int)bd & (int)(int)15) != (int)0)) {
HXLINE(  52)			HX_STACK_DO_THROW(HX_("assert",c6,46,03,4c));
            		}
HXLINE(  54)		if (streamSize) {
HXLINE(  55)			 ::cdb::Lz4Reader _hx_tmp3 = hx::ObjectPtr<OBJ_>(this);
HXDLIN(  55)			_hx_tmp3->pos = (_hx_tmp3->pos + (int)8);
            		}
HXLINE(  56)		if (presetDict) {
HXLINE(  57)			HX_STACK_DO_THROW(HX_("Preset dictionary not supported",98,8d,14,0d));
            		}
HXLINE(  59)		int headerChk = this->bytes->b->__get(this->pos++);
HXLINE(  61)		 ::haxe::io::Bytes out = ::haxe::io::Bytes_obj::alloc((int)128);
HXLINE(  62)		int outPos = (int)0;
HXLINE(  64)		while(true){
HXLINE(  65)			int size = this->bytes->b->__get(this->pos++);
HXDLIN(  65)			int size1 = ((int)size | (int)((int)this->bytes->b->__get(this->pos++) << (int)(int)8));
HXDLIN(  65)			int size2 = ((int)size1 | (int)((int)this->bytes->b->__get(this->pos++) << (int)(int)16));
HXDLIN(  65)			int size3 = ((int)size2 | (int)((int)this->bytes->b->__get(this->pos++) << (int)(int)24));
HXLINE(  66)			if ((size3 == (int)0)) {
HXLINE(  66)				goto _hx_goto_4;
            			}
HXLINE(  68)			if ((((int)size3 & (int)(int)-16) == (int)407710288)) {
HXLINE(  69)				int dataSize = this->bytes->b->__get(this->pos++);
HXDLIN(  69)				int dataSize1 = ((int)dataSize | (int)((int)this->bytes->b->__get(this->pos++) << (int)(int)8));
HXDLIN(  69)				int dataSize2 = ((int)dataSize1 | (int)((int)this->bytes->b->__get(this->pos++) << (int)(int)16));
HXDLIN(  69)				int dataSize3 = ((int)dataSize2 | (int)((int)this->bytes->b->__get(this->pos++) << (int)(int)24));
HXLINE(  70)				 ::cdb::Lz4Reader _hx_tmp4 = hx::ObjectPtr<OBJ_>(this);
HXDLIN(  70)				_hx_tmp4->pos = (_hx_tmp4->pos + dataSize3);
HXLINE(  71)				continue;
            			}
HXLINE(  73)			if ((((int)size3 & (int)(int)-2147483648) != (int)0)) {
HXLINE(  75)				size3 = ((int)size3 & (int)(int)2147483647);
HXLINE(  76)				if (((outPos + out->length) < size3)) {
HXLINE(  76)					out = this->grow(out,outPos,size3);
            				}
HXLINE(  77)				out->blit(outPos,bytes,this->pos,size3);
HXLINE(  78)				outPos = (outPos + size3);
HXLINE(  79)				 ::cdb::Lz4Reader _hx_tmp5 = hx::ObjectPtr<OBJ_>(this);
HXDLIN(  79)				_hx_tmp5->pos = (_hx_tmp5->pos + size3);
            			}
            			else {
HXLINE(  81)				int srcEnd = (this->pos + size3);
HXLINE(  82)				while((this->pos < srcEnd)){
HXLINE(  83)					int r = this->pos;
HXDLIN(  83)					::Array< int > r1 = ::cdb::Lz4Reader_obj::uncompress(bytes,r,(srcEnd - this->pos),out,outPos);
HXLINE(  84)					this->pos = r1->__get((int)0);
HXLINE(  85)					outPos = r1->__get((int)1);
HXLINE(  86)					int req = r1->__get((int)2);
HXLINE(  87)					if ((req > (int)0)) {
HXLINE(  88)						out = this->grow(out,outPos,req);
            					}
            				}
            			}
HXLINE(  91)			if (blockChecksum) {
HXLINE(  91)				 ::cdb::Lz4Reader _hx_tmp6 = hx::ObjectPtr<OBJ_>(this);
HXDLIN(  91)				_hx_tmp6->pos = (_hx_tmp6->pos + (int)4);
            			}
            		}
            		_hx_goto_4:;
HXLINE(  94)		return out->sub((int)0,outPos);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Lz4Reader_obj,read,return )

::Array< int > Lz4Reader_obj::uncompress( ::haxe::io::Bytes src,int srcPos,int srcLen, ::haxe::io::Bytes out,int outPos){
            	HX_STACKFRAME(&_hx_pos_d62c863b817f8066_97_uncompress)
HXLINE(  98)		int outSave = outPos;
HXLINE(  99)		int srcEnd = (srcPos + srcLen);
HXLINE( 100)		if ((srcLen == (int)0)) {
HXLINE( 101)			return ::Array_obj< int >::__new(3)->init(0,srcPos)->init(1,outPos)->init(2,(int)0);
            		}
HXLINE( 102)		int outLen = out->length;
HXLINE( 108)		while(true){
HXLINE( 109)			int start = srcPos;
HXLINE( 110)			srcPos = (srcPos + (int)1);
HXDLIN( 110)			int tk = src->b->__get((srcPos - (int)1));
HXLINE( 111)			int litLen = ((int)tk >> (int)(int)4);
HXLINE( 112)			int matchLen = ((int)tk & (int)(int)15);
HXLINE( 113)			if ((litLen == (int)15)) {
HXLINE( 114)				int b;
HXLINE( 115)				while(true){
HXLINE( 116)					srcPos = (srcPos + (int)1);
HXDLIN( 116)					b = src->b->__get((srcPos - (int)1));
HXLINE( 117)					litLen = (litLen + b);
HXLINE( 115)					if (!((b == (int)255))) {
HXLINE( 115)						goto _hx_goto_9;
            					}
            				}
            				_hx_goto_9:;
            			}
HXLINE( 128)			if (((outPos + litLen) > outLen)) {
HXLINE( 129)				return ::Array_obj< int >::__new(3)->init(0,start)->init(1,outPos)->init(2,(litLen + matchLen));
            			}
HXLINE( 131)			switch((int)(litLen)){
            				case (int)0: {
            				}
            				break;
            				case (int)1: {
HXLINE( 134)					srcPos = (srcPos + (int)1);
HXDLIN( 134)					out->b[outPos] = src->b->__get((srcPos - (int)1));
HXDLIN( 134)					outPos = (outPos + (int)1);
            				}
            				break;
            				case (int)2: {
HXLINE( 136)					{
HXLINE( 136)						srcPos = (srcPos + (int)1);
HXDLIN( 136)						out->b[outPos] = src->b->__get((srcPos - (int)1));
HXDLIN( 136)						outPos = (outPos + (int)1);
            					}
HXLINE( 137)					{
HXLINE( 137)						srcPos = (srcPos + (int)1);
HXDLIN( 137)						out->b[outPos] = src->b->__get((srcPos - (int)1));
HXDLIN( 137)						outPos = (outPos + (int)1);
            					}
            				}
            				break;
            				case (int)3: {
HXLINE( 139)					{
HXLINE( 139)						srcPos = (srcPos + (int)1);
HXDLIN( 139)						out->b[outPos] = src->b->__get((srcPos - (int)1));
HXDLIN( 139)						outPos = (outPos + (int)1);
            					}
HXLINE( 140)					{
HXLINE( 140)						srcPos = (srcPos + (int)1);
HXDLIN( 140)						out->b[outPos] = src->b->__get((srcPos - (int)1));
HXDLIN( 140)						outPos = (outPos + (int)1);
            					}
HXLINE( 141)					{
HXLINE( 141)						srcPos = (srcPos + (int)1);
HXDLIN( 141)						out->b[outPos] = src->b->__get((srcPos - (int)1));
HXDLIN( 141)						outPos = (outPos + (int)1);
            					}
            				}
            				break;
            				default:{
HXLINE( 143)					out->blit(outPos,src,srcPos,litLen);
HXLINE( 144)					outPos = (outPos + litLen);
HXLINE( 145)					srcPos = (srcPos + litLen);
            				}
            			}
HXLINE( 147)			if ((srcPos >= srcEnd)) {
HXLINE( 147)				goto _hx_goto_8;
            			}
HXLINE( 148)			srcPos = (srcPos + (int)1);
HXDLIN( 148)			int offset = src->b->__get((srcPos - (int)1));
HXLINE( 149)			srcPos = (srcPos + (int)1);
HXDLIN( 149)			offset = ((int)offset | (int)((int)src->b->__get((srcPos - (int)1)) << (int)(int)8));
HXLINE( 150)			if ((matchLen == (int)15)) {
HXLINE( 151)				int b1;
HXLINE( 152)				while(true){
HXLINE( 153)					srcPos = (srcPos + (int)1);
HXDLIN( 153)					b1 = src->b->__get((srcPos - (int)1));
HXLINE( 154)					matchLen = (matchLen + b1);
HXLINE( 152)					if (!((b1 == (int)255))) {
HXLINE( 152)						goto _hx_goto_10;
            					}
            				}
            				_hx_goto_10:;
            			}
HXLINE( 157)			matchLen = (matchLen + (int)4);
HXLINE( 159)			if (((outPos + matchLen) > outLen)) {
HXLINE( 160)				return ::Array_obj< int >::__new(3)->init(0,start)->init(1,(outPos - litLen))->init(2,(litLen + matchLen));
            			}
HXLINE( 162)			bool _hx_tmp;
HXDLIN( 162)			if ((matchLen >= (int)64)) {
HXLINE( 162)				_hx_tmp = (matchLen <= offset);
            			}
            			else {
HXLINE( 162)				_hx_tmp = false;
            			}
HXDLIN( 162)			if (_hx_tmp) {
HXLINE( 163)				out->blit(outPos,out,(outPos - offset),matchLen);
HXLINE( 164)				outPos = (outPos + matchLen);
            			}
            			else {
HXLINE( 166)				int copyEnd = (outPos + matchLen);
HXLINE( 167)				while((outPos < copyEnd)){
HXLINE( 168)					::Array< unsigned char > out1 = out->b;
HXDLIN( 168)					out->b[outPos] = out1->__get((outPos - offset));
HXDLIN( 168)					outPos = (outPos + (int)1);
            				}
            			}
            		}
            		_hx_goto_8:;
HXLINE( 171)		if ((srcPos != srcEnd)) {
HXLINE( 171)			HX_STACK_DO_THROW((HX_("Read too much data ",d9,79,4a,ea) + (srcPos - srcLen)));
            		}
HXLINE( 172)		return ::Array_obj< int >::__new(3)->init(0,srcPos)->init(1,outPos)->init(2,(int)0);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(Lz4Reader_obj,uncompress,return )

 ::haxe::io::Bytes Lz4Reader_obj::decodeString(::String s){
            	HX_GC_STACKFRAME(&_hx_pos_d62c863b817f8066_175_decodeString)
HXLINE( 176)		if ((s == HX_("",00,00,00,00))) {
HXLINE( 177)			return ::haxe::io::Bytes_obj::alloc((int)0);
            		}
HXLINE( 178)		 ::haxe::io::Bytes k = ::haxe::crypto::Base64_obj::decode(s,null());
HXLINE( 180)		bool _hx_tmp;
HXDLIN( 180)		bool _hx_tmp1;
HXDLIN( 180)		bool _hx_tmp2;
HXDLIN( 180)		if ((k->b->__get((int)0) == (int)4)) {
HXLINE( 180)			_hx_tmp2 = (k->b->__get((int)1) != (int)34);
            		}
            		else {
HXLINE( 180)			_hx_tmp2 = true;
            		}
HXDLIN( 180)		if (!(_hx_tmp2)) {
HXLINE( 180)			_hx_tmp1 = (k->b->__get((int)2) != (int)77);
            		}
            		else {
HXLINE( 180)			_hx_tmp1 = true;
            		}
HXDLIN( 180)		if (!(_hx_tmp1)) {
HXLINE( 180)			_hx_tmp = (k->b->__get((int)3) != (int)24);
            		}
            		else {
HXLINE( 180)			_hx_tmp = true;
            		}
HXDLIN( 180)		if (_hx_tmp) {
HXLINE( 181)			return k;
            		}
HXLINE( 190)		return  ::cdb::Lz4Reader_obj::__alloc( HX_CTX )->read(k);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Lz4Reader_obj,decodeString,return )

::String Lz4Reader_obj::encodeBytes( ::haxe::io::Bytes b,bool compress){
            	HX_STACKFRAME(&_hx_pos_d62c863b817f8066_194_encodeBytes)
HXLINE( 195)		bool _hx_tmp;
HXDLIN( 195)		if (compress) {
HXLINE( 195)			_hx_tmp = (b->length > (int)0);
            		}
            		else {
HXLINE( 195)			_hx_tmp = false;
            		}
HXLINE( 207)		return ::haxe::crypto::Base64_obj::encode(b,null());
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Lz4Reader_obj,encodeBytes,return )


hx::ObjectPtr< Lz4Reader_obj > Lz4Reader_obj::__new() {
	hx::ObjectPtr< Lz4Reader_obj > __this = new Lz4Reader_obj();
	__this->__construct();
	return __this;
}

hx::ObjectPtr< Lz4Reader_obj > Lz4Reader_obj::__alloc(hx::Ctx *_hx_ctx) {
	Lz4Reader_obj *__this = (Lz4Reader_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Lz4Reader_obj), true, "cdb.Lz4Reader"));
	*(void **)__this = Lz4Reader_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

Lz4Reader_obj::Lz4Reader_obj()
{
}

void Lz4Reader_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Lz4Reader);
	HX_MARK_MEMBER_NAME(bytes,"bytes");
	HX_MARK_MEMBER_NAME(pos,"pos");
	HX_MARK_END_CLASS();
}

void Lz4Reader_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(bytes,"bytes");
	HX_VISIT_MEMBER_NAME(pos,"pos");
}

hx::Val Lz4Reader_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"b") ) { return hx::Val( b_dyn() ); }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"pos") ) { return hx::Val( pos ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"grow") ) { return hx::Val( grow_dyn() ); }
		if (HX_FIELD_EQ(inName,"read") ) { return hx::Val( read_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"bytes") ) { return hx::Val( bytes ); }
	}
	return super::__Field(inName,inCallProp);
}

bool Lz4Reader_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 10:
		if (HX_FIELD_EQ(inName,"uncompress") ) { outValue = uncompress_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"encodeBytes") ) { outValue = encodeBytes_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"decodeString") ) { outValue = decodeString_dyn(); return true; }
	}
	return false;
}

hx::Val Lz4Reader_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"pos") ) { pos=inValue.Cast< int >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"bytes") ) { bytes=inValue.Cast<  ::haxe::io::Bytes >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Lz4Reader_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("bytes","\x6b","\x08","\x98","\xbd"));
	outFields->push(HX_HCSTRING("pos","\x94","\x5d","\x55","\x00"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo Lz4Reader_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*::haxe::io::Bytes*/ ,(int)offsetof(Lz4Reader_obj,bytes),HX_HCSTRING("bytes","\x6b","\x08","\x98","\xbd")},
	{hx::fsInt,(int)offsetof(Lz4Reader_obj,pos),HX_HCSTRING("pos","\x94","\x5d","\x55","\x00")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *Lz4Reader_obj_sStaticStorageInfo = 0;
#endif

static ::String Lz4Reader_obj_sMemberFields[] = {
	HX_HCSTRING("bytes","\x6b","\x08","\x98","\xbd"),
	HX_HCSTRING("pos","\x94","\x5d","\x55","\x00"),
	HX_HCSTRING("b","\x62","\x00","\x00","\x00"),
	HX_HCSTRING("grow","\x13","\xdc","\x6b","\x44"),
	HX_HCSTRING("read","\x56","\x4b","\xa7","\x4b"),
	::String(null()) };

static void Lz4Reader_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Lz4Reader_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Lz4Reader_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Lz4Reader_obj::__mClass,"__mClass");
};

#endif

hx::Class Lz4Reader_obj::__mClass;

static ::String Lz4Reader_obj_sStaticFields[] = {
	HX_HCSTRING("uncompress","\xfb","\x2e","\x83","\x09"),
	HX_HCSTRING("decodeString","\x9f","\x10","\x71","\x5f"),
	HX_HCSTRING("encodeBytes","\x75","\x36","\x2e","\xc9"),
	::String(null())
};

void Lz4Reader_obj::__register()
{
	hx::Object *dummy = new Lz4Reader_obj;
	Lz4Reader_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("cdb.Lz4Reader","\x9c","\xbb","\xf5","\x0f");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Lz4Reader_obj::__GetStatic;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = Lz4Reader_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Lz4Reader_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Lz4Reader_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Lz4Reader_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Lz4Reader_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Lz4Reader_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Lz4Reader_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace cdb
